# 对象机制
> Redis 并没有使用这些基本数据结构来实现数据库应用, 而是基于这些底层数据结构之上, 构建了一个对象系统, 所有的操作都是基于对象来进行操作

Redis的每种对象其实都由对象结构(redisObject) 与 对应编码的数据结构组合而成

<img width="573" alt="Screen Shot 2021-12-06 at 6 03 52 PM" src="https://user-images.githubusercontent.com/27160394/144826875-74ed825f-cb13-4de9-97ff-7d2c4ddab442.png">

## Why `redisObject`

* Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式.
* 操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.

类型系统
* redisObject 对象.
* 基于 redisObject 对象的类型检查.
* 基于 redisObject 对象的显式多态函数.
* 对 redisObject 进行分配、共享和销毁的机制

## redisObject数据结构
redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型.

<img width="401" alt="Screen Shot 2021-12-06 at 6 08 21 PM" src="https://user-images.githubusercontent.com/27160394/144827487-baad64f1-fa02-431e-85a0-7b77edacadbd.png">

```
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码方式
    unsigned encoding:4;

    // LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
    unsigned lru:LRU_BITS; // LRU_BITS: 24

    // 引用计数
    int refcount;

    // 指向底层数据结构实例
    void *ptr;

} robj;
  
```

* type记录了对象所保存的值的类型
* encoding记录了对象所保存的值的编码
* ptr是一个指针，指向实际保存值的数据结构
* lru属性: 记录了对象最后一次被命令程序访问的时间  
  * 空转时长：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长 
  * 如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，

### 命令的类型检查和多态
> 那么Redis是如何处理一条命令的呢？

**当执行一个处理数据类型命令的时候**
1. 根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL； 
2. 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误； 
3. 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构； 
4. 返回数据结构的操作结果作为命令的返回值。


### 对象共享
> redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。


* 将数据库键的值指针指向一个现有的值对象
* 将被共享的值对象的引用计数增一。

#### redis的预分配
Redis 会在初始化服务器时，创建一万个字符串对象
* 这些对象包含了从 0 到 9999 的所有整数值
* 当服务器需要用到值为0到 9999 的字符串对象时,服务器就会使用这些共享对象,而不是新创建对象。

redis预分配的值对象
* 各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等
* 包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）


共享对象使用范围
* 共享对象只能被带指针的数据结构使用。需要提醒的一点是， 共享对象只能被字典和双端链表这类能带有指针的数据结构使用。
* 像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构， 就不能使用共享对象。

**为什么redis不共享包含字符串的对象(列表对象、哈希对象、集合对象、有序集合对象), 只共享字符串对象？**

当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同
* 只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象
* 而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的 CPU 时间也会越多
* 如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1) 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N) 
* 如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N^2  )


### 引用计数以及对象的消毁(`ptr`)

> redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。
*  每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次； 
*  当新创建一个对象时，它的refcount属性被设置为1； 当对一个对象进行共享时，
*  redis将这个对象的refcount加一； 当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一； 
*  当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。
*  除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。

Summary
* redis使用自己实现的对象机制（redisObject)来实现类型判断、命令多态和基于引用次数的垃圾回收； 
* redis会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁的为小对象分配内存。


