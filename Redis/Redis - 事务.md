# Redis事务
> Redis事务的本质是一组命令的集合。

* 事务支持一次执行多个命令，一个事务中所有命令都会被序列化。
* 在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中

## Redis事务相关命令和使用
* `MULTI` ：开启事务，redis会将后续的命令逐个放入队列中。这个命令将客户端的 REDIS_MULTI 选项打开，让客户端从非事务状态切换到事务状态
* `EXEC`：执行事务中的所有操作命令。
* `DISCARD`：取消事务，放弃执行事务块中的所有命令。 
* `WATCH`：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。 
* `UNWATCH`：取消WATCH对所有key的监视。

### 事务执行
```
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 11
QUEUED
127.0.0.1:6379> set k2 22
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) OK
127.0.0.1:6379> get k1
"11"
127.0.0.1:6379> get k2
"22"

127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 33
QUEUED
127.0.0.1:6379> set k2 34
QUEUED
127.0.0.1:6379> DISCARD
OK
```

### 事务出现错误的处理
* 语法错误（编译器错误）:最终导致事务提交失败
```
著作权归https://pdai.tech所有。
链接：https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html

127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 11
QUEUED
127.0.0.1:6379> sets k2 22
(error) ERR unknown command `sets`, with args beginning with: `k2`, `22`, 
127.0.0.1:6379> exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get k2
"v2"
```
* Redis类型错误（运行时错误)
```
著作权归https://pdai.tech所有。
链接：https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html

127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 11
QUEUED
127.0.0.1:6379> lpush k2 22
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
```

###`WATCH`
> `WATCH`命令可以为 Redis 事务提供`check-and-set`(CAS)行为

被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键**在`WATCH`执行之后`EXEC` 执行之前**被修改了,那么整个事务都会被取消,`EXEC`返回nil-reply来表示事务已经失败

>`watch`是如何监视实现的呢？

Redis使用`WATCH`命令来决定事务是继续执行还是回滚，那就需要在`MULTI`之前使用`WATCH`来监控某些键值对
* 然后使用`MULTI`命令来开启事务,执行对数据结构操作的各种命令，此时这些命令入队列
* 当使用`EXEC`执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务
* 如果发生变化，将不会执行事务中的任何命令，同时事务回滚
* 当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。


### Redis事务执行步骤
1. 开启：以`MULTI`开始一个事务
2. 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
3. 执行：由`EXEC`命令触发事务

当一个客户端切换到事务状态之后， 服务器会根据这个客户端发来的不同命令执行不同的操
* 如果客户端发送的命令为 `EXEC,DISCARD,WATCH,MULTI `四个命令的其中一个， 那么服务器立即执行这个命令。
* 以外的其他命令,那么服务器并不立即执行这个命令,而是将这个命令放入一个事务队列里面,然后向客户端返回`QUEUED`回复

### 为什么 Redis 不支持回滚？
* redis事务执行中有命令执行出错，其它已正确执行的命令不会回滚
* Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的。
* 因为不需要对回滚进行支持，Redis 的内部可以保持简单且快速

### 如何理解Redis与事务的ACID？
* Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。
* redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结
* redis事务是单进程单线程模式可以保证命令执行过程中不会被其他客户端命令打断。但是，Redis不像其它结构化数据库有隔离级别这种设计
* redis事务是不保证持久性的，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑

### Redis事务其它实现
* 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完 
* 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐 ¶
