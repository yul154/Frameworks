> redis实现分布式锁，还有其他方式么

* SETNX + EXPIRE + DEL ： 如果执行完setnx加锁，正要执行expire设置过期时间时，进程crash或者要重启维护了，那么这个锁就“长生不老”了
* SETNX + value值是（系统时间+过期时间）
* 使用Lua脚本(包含SETNX + EXPIRE两条指令)
* SET的扩展命令（SET EX PX NX）
* SET EX PX NX  + 校验唯一随机值,再释放锁
* 开源框架~Redisson： 启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间
* 多机实现的分布式锁Redlock： 搞多个Redis master部署，让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败


> redis的几种数据类型，你们用过哪些，zset有用来做什么，hash 扩容

String	 Set	List	Zset Hash

链地址法，BGSAVE，负载因子大于等于1，渐近式 rehash


> redis管道用过么，用来做什么，它的原理是，保证原子性么，和事务的区别，redis事务保证原子性么

基于频道(Channel)的发布/订阅，底层是通过字典实现的，Redis是单线程队列IO复用机制，所有Redis的单个命令是原子性的，如果涉及到一次性执行多个命令，且需要把多个命令作为一个不可分割的处理序列，就必须依赖Redis的事务
redis事务执行中有命令执行出错


> redis强一致性么，怎么保证强一致性，有什么方案


> 怎么保证redis和mysql的一致性，redis网络原因执行超时了会执行成功么，那不成功怎么保证数据一致性


> .你们用的redis集群么，扩容的过程，各个节点间怎么通信的

Redis 的集群节点之间的通信采取gossip 协议进行通信

> redis线程模型，单线程有什么优缺点，为什么单线程能保证高性能，什么情况下会出现阻塞，怎么解决

Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的


> redis分布式锁，过期时间怎么定的，如果一个业务执行时间比较长，锁过期了怎么办，怎么保证释放锁的一个原子性，你们redis是集群的么，讲讲redlock算法


> Redis使用Lua脚本时为什么能保证原子性

Redis使用（支持）相同的Lua解释器，来运行所有的命令。Redis还保证脚本以原子方式执行：在执行脚本时，不会执行其他脚本或Redis命令。这个语义类似于MULTI（开启事务）/EXEC（触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成

当执行一个lua脚本时，redis同样是单线程执行的，也就是执行lua脚本时其他的指令是阻塞的，必须排队执行，这就是redis如何保证lua脚本里面的指令是一个整体而不会被其他指令干扰的

redis使用lua可以保证指令依次执行而不受其他指令干扰，但是不能保证指令最终必定是原子性的

lua 的替代方案是内置了 pcall(f) 函数调用。pcall 的意思是 protected call，它会让 f 函数运行在保护模式下，f 如果出现了错误，pcall 调用会返回 false 和错误信息。

> redis缓存穿透，布隆过滤器，怎么使用，有什么问题，怎么解决这个问题

一个很长的二进制向量和一系列随机映射函数。 布隆过滤器可以用于检索一个元素是否在一个集合中。 它的优点是空间效率和查询时间都远远超过一般的算法

> redis集群，为什么是16384，哨兵模式，选举过程，会有脑裂问题么，raft算法，优缺点

> redis字典结构，hash冲突怎么办，rehash，负载因子
在执行BGSAVE 命令或BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，
* 所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作，最大限度地节约内存
