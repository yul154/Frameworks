# 简单讲下Redis

* 用C语言编写的
* Key-Value类型的分布式内存数据库
* 整个数据库统统加载在内存当中进行操作
* 支持持久化的NoSQL数据库，
* 支持保存多种数据结构

在项目中使用redis，主要是从两个角度去考虑:性能和并发
* 性能：MYSQL需要IO，redis基于内存
* 并发：所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据

----
#  Redis 特别点
* Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
* Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储
* Redis支持数据的备份，即master-slave模式的数据备份
* 支持事务

## 优点
* 性能极高–Redis能读的速度是110000次/s,写的速度是81000次/s。
* 丰富的数据类型– Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作
* 原子– Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行.（事务）
* 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
* Redis支持 publish/subscribe, 通知等

## 缺点
* 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写
* Redis 事务支持比较弱，只能保证事务中的每个操作连续执行
* Redis只能使用单线程，性能受限于CPU性能

> 说一下 redis 和 mysql 的区别 

|Redis|Mysql|
|-----|-----|
|redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中|mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢|
|redis数据库就是一款缓存 数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率|mysql作为持久化存储的关系型数据库|
|redis用于存储使用较为频繁的数据到缓存中,读取速度快,基于内存,读写速度快,也可做持久化,内存空间有限|mysql用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高|
|需要高性能的地方使用Redis|不需要高性能的地方使用MySQL.一般都是配合使用，存储数据在MySQL和Redis之间做同步|



> 为什么Redis这么快？
* 采用了多路复用io阻塞机制: 只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流
* 数据结构简单，操作节省时间
* 单线程操作，避免了频繁的上下文切换 
* 最后，运行在内存中，自然速度快


> Redis是单线程的吗
其网络IO和键值对读写是由一个线程完成的
* Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。
* Redis 是基于内存操作的，它的瓶颈在于机器的内存、网络带宽，而不是 CPU，因为在你 CPU 还没达到瓶颈时你的内存可能就先满了、或者带宽达到瓶颈了。
* 因此 CPU 不是主要原因，那么自然就采用单线程了
* 采用 I/O 多路复用机制处理大量客户端的Socket请求，因为这是基于非阻塞的 I/O 模型，这就让Redis可以高效地进行网络通信，I/O的读写流程也不再阻塞

> IO 多路复用在 Redis 中的应用

多路复用
* 多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。
* IO多路复用在Linux下包括了三种，select、poll、epoll三种模式。

*  Redis 是跑在「单线程」中的，所有的操作都是按照顺序线性执行的
*  使用不阻塞方式处理多个 client 端请求问题,为了让单线程(进程)的服务端应用同时处理多个客户端的事件
*  使用一个线程来检查多个 Socket 的就绪状态，在单个线程中通过记录跟踪每一个 socket（I/O流）的状态来管理处理多个 I/O 流
*  是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，
*  redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。

## Redis使用场景
* 内存存储和持久化：支持异步将内存中的数据写到硬盘上，同时不影响继续服务
* 取最新N个数据的操作如：可以将最新的10条评论的ID放在Redis的List集合里面
* 缓存：缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略；
* 排行榜： 很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。
* 计数器：电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好
* 分布式锁：在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，
* 最新列表：Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可
* 分布式会话：集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。
* 消息系统：消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统.
* 社交网络：点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。


## 为什么Redis这么快？
* 首先，采用了多路复用io阻塞机制
* 然后，数据结构简单，操作节省时间
* 最后，运行在内存中，自然速度快


## 简述一下Redis值的五种类型
* String 整数，浮点数或者字符串
  * set/get/decr/incr/mget
  * 普通的key/value存储都可以归为此类
  * String在redis内部存储默认就是一个字符串
  * 当遇到incr、decr等操作时会转成数值型进行计算
  * 一般做一些复杂的计数功能的缓存
* Set 集合
  * sadd/spop/smembers/sunion
  * Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的
  * 并且set提供了判断某个成员是否在一个set集合内的重要接口
  * set 的内部实现是一个 value永远为null的HashMap
  * 利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能
* Zset 有序集合
  * zadd/zrange/zrem/zcard
  * sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序
  * 插入有序的，即自动排序
  * twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的
  * 可以做排行榜应用，取TOP N操作
  * Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序
    * HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员
    * 排序依据是HashMap里存的score,
    * 使用跳跃表的结构可以获得比较高的查找效率 
* Hash 散列表
  * hget/hset/hgetall
  * 存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日
  * Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口
  * Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值
  * 通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据
  * 博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key
* List 列表
  *  lpush/rpush/lpop/rpop/lrange
  *  twitter的关注列表，粉丝列表等都可以用Redis的list结构
  *  Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销
  *  可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能


## redis的过期策略以及内存淘汰机制

redis采用的是定期删除+惰性删除策略
* 定期删除
 * redis默认每个100ms检查，是否有过期的key,有过期key则删除
 * redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查
* 惰性删除派上用场
  * 如果只采用定期删除策略，会导致很多key到时间没有删除
  * 在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除


> 如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制
**Redis的数据淘汰机制**
* 当内存不足以容纳新写入数据时，
  * volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  * volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  * volatile-random从已设置过期时间的数据集中任意选择数据淘汰
  * allkeys-lru从所有数据集中挑选最近最少使用的数据淘汰
  * allkeys-random从所有数据集中任意选择数据进行淘汰
  * noeviction :新写入操作会报错。应该没人用吧
----
# 如何保持mysql和redis中数据的一致性？

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性
* 强一致性对于关系型数据库，要求更新过的数据能被后续的访问都能看到，
* 弱一致性： 能容忍后续的部分或者全部访问不到。 
* 最终一致性：如果经过一段时间后要求能访问到更新后的数据，
* 如果对数据有强一致性要求，不能放缓存。
* 只能说降低不一致发生的概率，无法完全避免


* 延时双删策略 先删除缓存 -> 再更新数据库 -> 休眠一会（比如1秒），再次删除缓存。  
 * 第二次删除缓存失败 -> 给Key设置一个自然的expire过期时间，让它自动过期 

* 删除缓存重试机制: 写请求更新数据库 ->缓存因为某些原因，删除失败 -> 把删除失败的key放到消息队列 ->  消费消息队列的消息，获取要删除的key -> 重试删除缓存操作

* 异步更新缓存(基于订阅binlog的同步机制): 对MySQL的binlog进行订阅 -> 这样一旦MySQL中产生了新的写入、更新、删除等操作 -> 把binlog相关的消息推送至Redis
 1。更新数据库数据
 2. 数据库会将操作信息写入binlog日志当中
 3. 订阅程序提取出所需要的数据以及key
 4. 另起一段非业务代码，获得该信息
 5. 尝试删除缓存操作，发现删除失败
 6. 将这些信息发送至消息队列
 7. 重新从消息队列中获得该数据，重试操作
---
# 缓存穿透，缓存雪崩以及缓存击穿

* 缓存穿透就是客户持续向服务器发起对不存在服务器中数据的请求.客户先在Redis中查询，查询不到后去数据库中查询，数据库原本就没有的数据，请求如入无人之境，直奔数据库
  * 拦截机制，迅速判断出，请求所携带的Key是否合法有效 ， 比如说我们的id是从1开始的，那么id<=0的直接拦截；
  * 缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击
  * 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
  
* 缓存击穿：数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了
  * 设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员 
* 缓存雪崩：就是大量数据同一时间失效。
  * 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 
  * 如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中
----
# 如何解决redis的并发竞争key问题

同时有多个子系统去set一个key。这个时候要注意什么呢
1. 如果对这个key操作，不要求顺序 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。
2. 如果对这个key操作，要求顺序 
 * 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。
 * 这种时候我们在数据写入数据库的时候，需要保存一个时间戳
 * 这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了
----
## Redis 持久化
> Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了
redis提供两种方式进行持久化
* RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化）
* AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。

### RDB
RDB持久化是指将某个时间点的所有数据都存放到硬盘上
* 实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
* 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
* 如果系统发生故障，将会丢失最后一次创建快照之后的数据。

优点
* 存储的文件是紧凑的
* 适合用于备份，方便恢复不同版本的数据
* 适合于容灾恢复，备份文件可以在其他服务器恢复
* 最大化了Redis的性能，备份的时候启动的是子线程，父进程不需要执行IO操作
* 数据保存比AOF要快

缺点
* 如果Redis因为没有正确关闭而停止工作是，到上个保存点之间的数据将会丢失
* 由于需要经常fork子线程来进行备份操作，如果数据量很大的话，fork比较耗时，如果cpu性能不够，服务器可能是卡顿。属于数据量大的时候，一个服务器不要部署多个Redis服务。

> 创建快照有以下5种形式


### AOF
以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，
* 将写命令添加到 AOF 文件（Append Only File）的末尾。 以文本的方式记录，可以打开文件看到详细的操作记录。
* AOF记录服务器的所有写操作。在服务器重新启动的时候，会把所有的写操作重新执行一遍，从而实现数据备份
* 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机
  * 对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘

优点
* 使用AOF模式更加的灵活，因为可以有不同的fsync策略
* AOF是一个日志追加文件，所有不需要定位，就算断电也没有损坏问题，哪怕文件末尾是一个写到一半的命令，redus-check-aof工具也可以很轻易的修复
* 当AOF文件很大的，Redis会自动在后台进行重写。重写是决对安全的，因为Redis是继续往旧的文件里面追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦创建完成，Redis就会切换到新文件，开始往新文件进行追加操作
* AOF包含一个又一个的操作命令，易于理解和解析

缺点

* 对于同样的数据集，AOF文件通常要大于RDB文件
* AOF可能比RDB要慢，这取决于fsync策略。通常fsync设置为每秒一次的话性能仍然很高，如果关闭sfync，即使在很高的负载下也和RDB一样快。不过，即使在很大的写负载情况下，RDB还是能提供很好的最大延迟保证
* AOF通过递增的方式更新数据，而RDB快照是从头开始创建，RDB会更健壮和稳定（所以适用于备份）


---

## Redis分布式锁

分布式锁至少要确保锁的实现同时满足以下四个条件：
1. 互斥性。在任意时刻，只有一个客户端能持有锁。
2. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
3. 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
4. 加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了

本质上要实现的目标就是一个进程在 Redis 里面占据了仅有的一个“茅坑”，当别的进程也想来占坑时，发现已经有人蹲在那里了，就只好放弃或者等待稍后再试。

Redis 锁主要利用 Redis 的 setnx 命令。
* 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
* 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
* 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放



SETNX 和 EXPIRE 非原子性( 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样)
* 这个锁就永远得不到释放了。
* 如果SETNX成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致EXPIRE命令没有执行，锁没有设置超时时间变成死锁
* 可以使用 Redis 的 SET 指令的扩展参数，使得 SETNX 和 EXPIRE 这两个操作可以原子执行


----
# Redis中的Master-Slave模式
**连接过程**
* 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
* 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令
* 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

**主从链**
随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。
* 为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。
* 中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器

**Sentinel（哨兵)**
* 可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

> Redis的哨兵
哨兵是 Redis 的一种运行模式，它专注于对 Redis 实例（主节点、从节点）运行状态的监控  并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性
* 监控：持续监控 master 、slave 是否处于预期工作状态
* 自动切换主库：当 Master 运行故障，哨兵启动自动故障恢复流程：从 slave 中选择一台作为新 master。
* 通知：让 slave 执行 replicaof ，与新的 master 同步；并且通知客户端与新 master 建立连接。
----
# 分片
> 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，
根据执行分片的位置，可以分为三种分片方式：
* 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
* 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
* 服务器分片：Redis Cluster
----

# redis 分布式事务




> Rdb 快照会影响目前线程执行任务嘛？（BGSAVE 用子进程操作，不会影响） 
> 说一下 redis 的淘汰策略（LRU）： 
> 你知道 redis 的 lru 怎么实现的嘛？（不太会） 

> redis 一般怎么用的？为什么选择用 redis？为什么 redis 快呢？
> redis 几种数据类型？redis string 的底层实现？
>  分布式锁用过吗？说说怎么用的？用的哪个命令？
>  redis 底层 hash 表扩容机制说一下？
