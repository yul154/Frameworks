# 简单讲下Redis

* 用C语言编写的
* Key-Value类型的分布式内存数据库
* 整个数据库统统加载在内存当中进行操作
* 支持持久化的NoSQL数据库，
* 支持保存多种数据结构

在项目中使用redis，主要是从两个角度去考虑:性能和并发
* 性能：MYSQL需要IO，redis基于内存
* 并发：所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据

----
#  Redis 特别点
* Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
* Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储
* Redis支持数据的备份，即master-slave模式的数据备份
* 支持事务

## 优点
* 性能极高–Redis能读的速度是110000次/s,写的速度是81000次/s。
* 丰富的数据类型– Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作
* 原子– Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行.（事务）
* 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
* Redis支持 publish/subscribe, 通知等

## 缺点
* 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写
* Redis 事务支持比较弱，只能保证事务中的每个操作连续执行
* Redis只能使用单线程，性能受限于CPU性能

> 说一下 redis 和 mysql 的区别 

|Redis|Mysql|
|-----|-----|
|redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中|mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢|
|redis数据库就是一款缓存 数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率|mysql作为持久化存储的关系型数据库|
|redis用于存储使用较为频繁的数据到缓存中,读取速度快,基于内存,读写速度快,也可做持久化,内存空间有限|mysql用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高|
|需要高性能的地方使用Redis|不需要高性能的地方使用MySQL.一般都是配合使用，存储数据在MySQL和Redis之间做同步|


> 为什么Redis这么快？
* 采用了多路复用io阻塞机制: 只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流
* 数据结构简单，操作节省时间
* 单线程操作，避免了频繁的上下文切换 
* 最后，运行在内存中，自然速度快


> Redis是单线程的吗

其网络IO和键值对读写是由一个线程完成的
* Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。
* Redis 是基于内存操作的，它的瓶颈在于机器的内存、网络带宽，而不是 CPU，因为在你 CPU 还没达到瓶颈时你的内存可能就先满了、或者带宽达到瓶颈了。
* 因此 CPU 不是主要原因，那么自然就采用单线程了
* 采用 I/O 多路复用机制处理大量客户端的Socket请求，因为这是基于非阻塞的 I/O 模型，这就让Redis可以高效地进行网络通信，I/O的读写流程也不再阻塞

> IO 多路复用在 Redis 中的应用
IO 多路复用 简单理解就是：一个服务端进程可以同时处理多个套接字描述符。
* 多路：多个客户端连接（连接就是套接字描述符）
* 复用：使用单进程就能够实现同时处理多个客户端的连接
* IO 多路复用只需要一个进程就能够处理多个套接字，从而解决了上下文切换的问题
* 多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。

IO多路复用在Linux下包括了三种，select、poll、epoll三种模式。 
  * select 就是轮询，在 Linux 上限制个数一般为 1024 个
  * poll 解决了 select 的个数限制，但是依然是轮询
  * epoll 解决了个数的限制，同时解决了轮询的方式
  * redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。

IO 多路复用在 Redis 中的应用
*  Redis 是跑在「单线程」中的，所有的操作都是按照顺序线性执行的
*  使用不阻塞方式处理多个 client 端请求问题,为了让单线程(进程)的服务端应用同时处理多个客户端的事件
*  使用一个线程来检查多个 Socket 的就绪状态，在单个线程中通过记录跟踪每一个 socket（I/O流）的状态来管理处理多个 I/O 流
*  是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，



## Redis使用场景

* 缓存：缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略；

* 排行榜： 很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。

* 计数器：电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好

* 分布式锁：在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，

* 最新列表：Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可

* 分布式会话：集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。

* 消息系统：消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统.

* 社交网络：点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。

```
一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：

**业务数据常用吗？命中率如何？**如果命中率很低，就没有必要写入缓存；
**该业务数据是读操作多，还是写操作多？**如果写操作多，频繁需要写入数据库，也没有必要使用缓存；
**业务数据大小如何？**如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；
```

```
高速读/写的场合
在某一个瞬间或者是某一个短暂的时刻有成千上万的请求到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机，而这样的场合都是不允许的！
```


## 为什么Redis这么快？
* 首先，采用了多路复用io阻塞机制
* 然后，数据结构简单，操作节省时间
* 最后，运行在内存中，自然速度快


## 简述一下Redis值的五种类型

**首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型**

**redis中并没有直接使用以上所说的各种数据结构来实现键值数据库，而是基于一种对象，对象底层再间接的引用上文所说的具体的数据结构**

<img width="449" alt="Screen Shot 2021-12-05 at 10 45 10 PM" src="https://user-images.githubusercontent.com/27160394/144751423-67464484-6bbb-42c0-8db9-8c61664e4e86.png">

|结构类型|值|结构的读写能力|
|-------|--|-----------|
|String|整数，浮点数或者字符串|对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作|
|Set|包含字符串的无序集合|字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等|
|List|一个双向链表,每个节点都包含一个字符串|对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素|
|Zset|和散列一样，用于存储键值对|字符串成员与浮点数分数之间的有序映射,元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素|
|Hash|包含键值对的无序散列表|包含方法有添加、获取、删除单个元素|

### String 整数，浮点数或者字符串

* 普通的key/value存储都可以归为此类,可以是字符串、整数或浮点数
* String在redis内部存储默认就是一个字符串
* 当遇到incr、decr等操作时会转成数值型进行计算
* 对整数或浮点数进行自增或自减操作,一般做一些复杂的计数功能的缓存


|命令|简述|使用|
|---|----|----|
|`GET`|获取存储在给定键中的值|`GET name`|
|`SET `|设置存储在给定键中的值|`SET name value`
|`DEL`| 删除存储在给定键中的值|`DEL name`
|`INCR`|将键存储的值加1|`INCR key`|
|`DECR` | 将键存储的值减1| `DECR key`|
|`INCRBY`| 将键存储的值加上整数| `INCRBY key amount`| 
|`DECRBY`|将键存储的值减去整数| `DECRBY key amount`| 


```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> get hello
"world"

127.0.0.1:6379> get counter
"2"
127.0.0.1:6379> incr counter
(integer) 3
127.0.0.1:6379> get counter
"3"
```

**业务场景**
* 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。 
* 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。 
* session：常见方案spring session + redis实现session共享，

> 底层实现

<img width="306" alt="Screen Shot 2021-12-05 at 11 56 19 PM" src="https://user-images.githubusercontent.com/27160394/144753797-1ae5551e-e750-4e92-8965-15aa00f1894f.png">

redis中所有场景中出现的字符串，基本都是由SDS(simple dynamic string)来实现的

<img width="348" alt="Screen Shot 2021-12-05 at 11 28 15 PM" src="https://user-images.githubusercontent.com/27160394/144752886-89eae101-fde9-42dd-a23e-ec83387449b6.png">

* free:还剩多少空间
* len:字符串长度
* buf:存放的字符数组

空间预分配
* 为减少修改字符串带来的内存重分配次数，sds采用了“一次管够”的策略
* 若修改之后sds长度小于1MB,则多分配现有len长度的空间
* 若修改之后sds长度大于等于1MB，则扩充除了满足修改之后的长度外，额外多1MB空间

惰性空间释放
* 为避免缩短字符串时候的内存重分配操作，sds在数据减少时，并不立刻释放空间。


### Set 集合
> Redis 的 Set 是 String 类型的无序无重集合

* 并且set提供了判断某个成员是否在一个set集合内的重要接口
* set 的内部实现是一个 value永远为null的HashMap
* 利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能

|命令|简述|使用|
|---|----|----|
|`SADD`|向集合添加一个或多个成员|`SADD key value`|
|`SCARD`|获取集合的成员数|`SCARD key`| 
|`SMEMBER`|返回集合中的所有成员|`SMEMBER key member`|
|`SISMEMBER`|判断 member 元素是否是集合 key 的成员|`SISMEMBER key member`|

```
著作权归https://pdai.tech所有。
链接：https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html

127.0.0.1:6379> sadd myset hao hao1 xiaohao hao
(integer) 3
127.0.0.1:6379> smember myset
1) "xiaohao"
2) "hao1"
3) "hao"
127.0.0.1:6379> sismember myset hao
(integer) 1
```
**实战场景**
* 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。
* 点赞，或点踩，收藏等，可以放到set中实现

<img width="304" alt="Screen Shot 2021-12-05 at 11 58 49 PM" src="https://user-images.githubusercontent.com/27160394/144753848-bd739375-118b-4008-b10e-4c6ffba031f8.png">

> 底层实现

intset是集合键的底层实现方式之一。

### Zset 有序集合
> 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序

* 和散列一样，用于存储键值对,字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定
* sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序
* 插入有序的，即自动排序
* twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的
* 可以做排行榜应用，取TOP N操作
* Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序
  * HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员
  * 排序依据是HashMap里存的score,
  * 使用跳跃表的结构可以获得比较高的查找效率 


|命令|简述|使用|
|---|----|----|
|`ZADD`|将一个带有给定分值的成员添加到哦有序集合里面|`ZADD zset-key 178 member1`|
|`ZRANGE`| 根据元素在有序集合中所处的位置，从有序集合中获取多个元素|`ZRANGE zset-key 0-1 withccores`|
|`ZREM`| 如果给定元素成员存在于有序集合中，那么就移除这个元素 |`ZREM zset-key member1`|

```

127.0.0.1:6379> zadd myscoreset 100 hao 90 xiaohao
(integer) 2
127.0.0.1:6379> ZRANGE myscoreset 0 -1
1) "xiaohao"
2) "hao"
127.0.0.1:6379> ZSCORE myscoreset hao
"100"
```

**实战场景**
* 排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行


> 底层实现

ziplist：它是由连续的内存块组成的

<img width="433" alt="Screen Shot 2021-12-05 at 11 37 28 PM" src="https://user-images.githubusercontent.com/27160394/144753206-eb4c83a4-8ae0-4f08-a839-c5e36d687c30.png">

**entry**
* previous_entry_length字段，他的长度要么都是1个字节，要么都是5个字节：
* 前一节点的长度小于254字节，则previous_entry_length长度为1字节
* 前一节点的长度小于254字节，则previous_entry_length长度为5字节
<img width="426" alt="Screen Shot 2021-12-05 at 11 38 23 PM" src="https://user-images.githubusercontent.com/27160394/144753231-164243bd-2d8c-48b8-9e18-ea7be12ce9d4.png">

1.元素的遍历
2.再根据ziplist节点元素中的previous_entry_length属性，来逐个遍历

<img width="304" alt="Screen Shot 2021-12-05 at 11 59 26 PM" src="https://user-images.githubusercontent.com/27160394/144753876-affad56b-4c69-459d-9499-3ddbf8d7cdca.png">

### Hash 散列表
> Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。

* 存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日
* Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口
* Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值
* 通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据
* 博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key

|命令|简述|使用|
|---|----|----|
|`HSET`| 添加键值对|`HSET hash-key sub-key1 value1`|
|`HGET`|获取指定散列键的值 |`HGET hash-key key1`|
|`HGETALL`| 获取散列中包含的所有键值对 |`HGETALL hash-key`|
|`HDEL`|如果给定键存在于散列中，那么就移除这个键 | `HDEL hash-key sub-key1`|

```
127.0.0.1:6379> hset user name1 hao
(integer) 1
127.0.0.1:6379> hset user email1 hao@163.com
(integer) 1
127.0.0.1:6379> hgetall user
1) "name1"
2) "hao"
3) "email1"
4) "hao@163.com"
127.0.0.1:6379> hget user user
(nil)
127.0.0.1:6379> hget user name1
```

**实战场景**
* 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。

### Hash 散列表是怎么扩容的

<img width="320" alt="Screen Shot 2021-12-06 at 12 00 01 AM" src="https://user-images.githubusercontent.com/27160394/144753887-d04a2e83-34fe-4dba-9049-124e0c578361.png">

* redis的哈希表的制作使用的是拉链法

<img width="543" alt="Screen Shot 2021-12-05 at 11 50 37 PM" src="https://user-images.githubusercontent.com/27160394/144753624-097f14bb-3af1-4431-af2f-ea89540197a6.png">

**rehash**
统筹”部分，其中有两个关键的属性：ht和rehashidx。
* rehashidx指的是现在rehash的元素位置
* ht是一个数组有且只有俩元素ht[0]和ht[1];其中，
  * ht[0]存放的是redis中使用的哈希表，
  * ht[1]和rehashidx和哈希表的rehash有关

**扩容和收缩标准**
扩容：
* 没有执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的加载因子大于等于1。
* 正在执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的加载因子大于等于5。

收缩:
* 加载因子小于0.1时，程序自动开始对哈希表进行收缩操作

扩容和收缩的数量
扩容：
* 第一个大于等于ht[0].used * 2的2^n(2的n次方幂)。
收缩：
* 第一个大于等于ht[0].used的2^n(2的n次方幂)

渐进式refresh:
1. 将ht[0]中的数据利用哈希函数重新计算
2. rehash到ht[1]

```
统筹”部分中的rehashidx密切相关
* rehashidx 的数值就是现在rehash的元素位置
* rehashidx 等于 -1 的时候说明没有在进行refresh
```

###  List 列表

*  一个链表，链表上的每个节点都包含一个字符串
*  Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销
*  可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能
*  Twitter的关注列表，粉丝列表等都可以用Redis的list结构


|命令|简述|使用|
|---|----|----|
|`RPUSH`|将给定值推入到列表右端|`RPUSH key value`|
|`LPUSH`|将给定值推入到列表左端|`LPUSH key value`|
|`RPOP`|从列表的右端弹出一个值，并返回被弹出的值| `RPOP key`|
|`LPOP`|从列表的左端弹出一个值，并返回被弹出的值|`LPOP key`|
|`LRANGE`|获取列表在给定范围上的所有值|`LRANGE key 0 -1`|
|`LINDEX`|通过索引获取列表中的元素。你也可以使用负数下标以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推|`LINEX key index`| 

```
127.0.0.1:6379> lpush mylist 1 2 ll ls mem
(integer) 5
127.0.0.1:6379> lrange mylist 0 -1
1) "mem"
2) "ls"
3) "ll"
4) "2"
5) "1"
127.0.0.1:6379> lindex mylist -1
"1"
127.0.0.1:6379> lindex mylist 10        # index不在 mylist 的区间范围内
(nil)
```

**实战场景**
* 微博TimeLine: 有人发布微博，用lpush加入时间轴，展示新的列表信息。
* 消息队列

> 底层实现
一部分是“统筹部分”：橘黄色，一部分是“具体实施方“：蓝色。
<img width="407" alt="Screen Shot 2021-12-05 at 11 32 10 PM" src="https://user-images.githubusercontent.com/27160394/144753014-538cc70f-1723-4ffb-809f-1490c59a79fc.png">

* head指向具体双向链表的头
* tail指向具体双向链表的尾
* len双向链表的长度



----
## redis的过期策略以及内存淘汰机制

* 惰性删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key，很明显，这是被动的。
* 定期删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 redis 会定期主动淘汰一批已过期的key。
* 主动删除：当前已用内存超过maxMemory限定时，触发主动清理策略。主动设置的前提是设置了maxMemory的值。

redis采用的是定期删除+惰性删除策略
* 定期删除
 * redis默认每个100ms检查，是否有过期的key,有过期key则删除
 * redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查
* 惰性删除派上用场
  * 如果只采用定期删除策略，会导致很多key到时间没有删除
  * 当读/写一个已经key时，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除


> 如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制
**Redis的数据淘汰机制**
* 当内存不足以容纳新写入数据时，
  * volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  * volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  * volatile-random从已设置过期时间的数据集中任意选择数据淘汰
  * allkeys-lru从所有数据集中挑选最近最少使用的数据淘汰
  * allkeys-random从所有数据集中任意选择数据进行淘汰
  * noeviction :新写入操作会报错。应该没人用吧
 
----
# 如何保持mysql和redis中数据的一致性？

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性
* 强一致性对于关系型数据库，要求更新过的数据能被后续的访问都能看到，
* 弱一致性： 能容忍后续的部分或者全部访问不到。 
* 最终一致性：如果经过一段时间后要求能访问到更新后的数据，
* 如果对数据有强一致性要求，不能放缓存。
* 只能说降低不一致发生的概率，无法完全避免


* 延时双删策略 先删除缓存 -> 再更新数据库 -> 休眠一会（比如1秒），再次删除缓存。  
 * 第二次删除缓存失败 -> 给Key设置一个自然的expire过期时间，让它自动过期 

* 删除缓存重试机制: 写请求更新数据库 ->缓存因为某些原因，删除失败 -> 把删除失败的key放到消息队列 ->  消费消息队列的消息，获取要删除的key -> 重试删除缓存操作

* 异步更新缓存(基于订阅binlog的同步机制): 对MySQL的binlog进行订阅 -> 这样一旦MySQL中产生了新的写入、更新、删除等操作 -> 把binlog相关的消息推送至Redis
 1。更新数据库数据
 2. 数据库会将操作信息写入binlog日志当中
 3. 订阅程序提取出所需要的数据以及key
 4. 另起一段非业务代码，获得该信息
 5. 尝试删除缓存操作，发现删除失败
 6. 将这些信息发送至消息队列
 7. 重新从消息队列中获得该数据，重试操作
---
# 缓存穿透，缓存雪崩以及缓存击穿

* 缓存穿透就是客户持续向服务器发起对不存在服务器中数据的请求.客户先在Redis中查询，查询不到后去数据库中查询，数据库原本就没有的数据，请求如入无人之境，直奔数据库
  * 拦截机制，迅速判断出，请求所携带的Key是否合法有效 ， 比如说我们的id是从1开始的，那么id<=0的直接拦截；
  * 缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击
  * 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
  
* 缓存击穿：数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了
  * 设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员 
* 缓存雪崩：就是大量数据同一时间失效。
  * 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 
  * 如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中
----
# 如何解决redis的并发竞争key问题

同时有多个子系统去set一个key。这个时候要注意什么呢
1. 如果对这个key操作，不要求顺序 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。
2. 如果对这个key操作，要求顺序 
 * 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。
 * 这种时候我们在数据写入数据库的时候，需要保存一个时间戳
 * 这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了
----
## Redis 持久化
> Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了
redis提供两种方式进行持久化
* RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化）
* AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。

### RDB
RDB持久化是指将某个时间点的所有数据都存放到硬盘上
* 实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
* 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
* 如果系统发生故障，将会丢失最后一次创建快照之后的数据。

优点
* 存储的文件是紧凑的
* 适合用于备份，方便恢复不同版本的数据
* 适合于容灾恢复，备份文件可以在其他服务器恢复
* 最大化了Redis的性能，备份的时候启动的是子线程，父进程不需要执行IO操作
* 数据保存比AOF要快

缺点
* 如果Redis因为没有正确关闭而停止工作是，到上个保存点之间的数据将会丢失
* 由于需要经常fork子线程来进行备份操作，如果数据量很大的话，fork比较耗时，如果cpu性能不够，服务器可能是卡顿。属于数据量大的时候，一个服务器不要部署多个Redis服务。

> 创建快照有以下5种形式
1. 客户端发送`BGSAVE`指令，服务端会fork一条子线程将快照写入磁盘
2. 客户端发送`SAVE`指令，服务端在主线程进行写入动作。一般不常使用，一般在内存不够去执行`BGSAVE`的时候才用
3. 设置了SAVE配置项，如SAVE 300 100，那么当“300秒内有100次写入”时，Redus会自动触发BGSAVE命令。如果有多个配置项，任意一个满足，都会触发备份
4. `SHUTDOWN`命令接收到关闭服务器的请求、或者TERM信号时，会执行SAVE命令，这时候会阻塞所有客户端，不在执行客户端发送的任何命令
5. 一个Redis服务器连接另外一个Redis服务器，并像对方发送`SYNC`命令开始一次复制操作时，如果主服务器目前没有在执行`BGSAVE`操作，或者主服务器刚刚执行完，那么主服务器就会执行`GBSAVE`


### AOF
以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，
* 将写命令添加到 AOF 文件（Append Only File）的末尾。 以文本的方式记录，可以打开文件看到详细的操作记录。
* AOF记录服务器的所有写操作。在服务器重新启动的时候，会把所有的写操作重新执行一遍，从而实现数据备份
* 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机
  * 对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘

优点
* 使用AOF模式更加的灵活，因为可以有不同的fsync策略
* AOF是一个日志追加文件，所有不需要定位，就算断电也没有损坏问题，哪怕文件末尾是一个写到一半的命令，redus-check-aof工具也可以很轻易的修复
* 当AOF文件很大的，Redis会自动在后台进行重写。重写是决对安全的，因为Redis是继续往旧的文件里面追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦创建完成，Redis就会切换到新文件，开始往新文件进行追加操作
* AOF包含一个又一个的操作命令，易于理解和解析

缺点

* 对于同样的数据集，AOF文件通常要大于RDB文件
* AOF可能比RDB要慢，这取决于fsync策略。通常fsync设置为每秒一次的话性能仍然很高，如果关闭sfync，即使在很高的负载下也和RDB一样快。不过，即使在很大的写负载情况下，RDB还是能提供很好的最大延迟保证
* AOF通过递增的方式更新数据，而RDB快照是从头开始创建，RDB会更健壮和稳定（所以适用于备份）

---

## Redis分布式锁

分布式锁至少要确保锁的实现同时满足以下四个条件：
1. 互斥性。在任意时刻，只有一个客户端能持有锁。
2. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
3. 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
4. 加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了

本质上要实现的目标就是一个进程在 Redis 里面占据了仅有的一个“茅坑”，当别的进程也想来占坑时，发现已经有人蹲在那里了，就只好放弃或者等待稍后再试。

Redis 锁主要利用 Redis 的 setnx 命令。
* 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
* 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
* 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放

SETNX 和 EXPIRE 非原子性( 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样)
* 这个锁就永远得不到释放了。
* 如果SETNX成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致EXPIRE命令没有执行，锁没有设置超时时间变成死锁
* 可以使用 Redis 的 SET 指令的扩展参数，使得 SETNX 和 EXPIRE 这两个操作可以原子执行

----

# Redis中的Master-Slave模式

Redis主从架构，一主多从，可以满足高可用和高并发。出现实例宕机自动进行主备切换，配置读写分离缓解Master读写压力。

**连接过程**
* 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
* 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令
* 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

**主从链**
随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。
* 为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。
* 中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器

1. 一个Slave实例，无论是第一次连接还是重连到Master，它都会发出一个SYNC命令；
2. 当Master收到SYNC命令之后，会做两件事：
 1.  Master执行BGSAVE，即在后台保存数据到磁盘（rdb快照文件)
 2.  Master同时将新收到的写入和修改数据集的命令存入缓冲区（非查询类）
3. 当Master在后台把数据保存到快照文件完成之后，Master会把这个快照文件传送给Slave，而Slave则把内存清空后，加载该文件到内存中
4. 而Master也会把此前收集到缓冲区中的命令，通过Reids命令协议形式转发给Slave，Slave执行这些命令，实现和Master的同步；
5. Master/Slave此后会不断通过异步方式进行命令的同步，达到最终数据的同步一致；

> 主从延迟导致读取到过期数据怎么处理
1. 通过scan命令扫库：当redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测，充分发挥redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。
2. redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。


**Sentinel（哨兵)**
* 可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

> Redis的哨兵
哨兵是 Redis 的一种运行模式，它专注于对 Redis 实例（主节点、从节点）运行状态的监控  并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性
* 监控：持续监控 master 、slave 是否处于预期工作状态
* 自动切换主库：当 Master 运行故障，哨兵启动自动故障恢复流程：从 slave 中选择一台作为新 master。
* 通知：让 slave 执行 replicaof ，与新的 master 同步；并且通知客户端与新 master 建立连接。

> Redis哨兵机制的原理
* 通过sentinel模式启动redis后，自动监控master/slave的运行状态
* 基本原理是：心跳机制+投票裁决
* 每个sentinel会向其它sentinal、master、slave定时发送消息，以确认对方是否活着，如果发现对方在指定时间内未回应，则暂时认为对方宕机。
* 若哨兵群中的多数sentinel都报告某一master没响应，系统才认为该master真正宕机
* 通过Raft投票算法，从剩下的slave节点中，选一台提升为master，然后自动修改相关配置。

哨兵至少需要3个实例，来保证自己的健壮性。

----
# 分片
> 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，
根据执行分片的位置，可以分为三种分片方式：
* 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
* 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
* 服务器分片：Redis Cluster
----

# redis 分布式事务




----
> Rdb 快照会影响目前线程执行任务嘛？（BGSAVE 用子进程操作，不会影响） 
> 你知道 redis 的 lru 怎么实现的嘛？（不太会） 

> redis 一般怎么用的？为什么选择用 redis？为什么 redis 快呢？


> redis 几种数据类型？redis string 的底层实现？
>  分布式锁用过吗？说说怎么用的？用的哪个命令？
>  redis 底层 hash 表扩容机制说一下？
